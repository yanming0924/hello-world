封装：

1.定义：隐藏对象的属性和实现细节，仅对外公开接口,控制在程序中属性的读和修改的访问级别。

2.封装的目的是：增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，一特定的访问权限来使用类的成员。

3.封装的基本要求是:把所有的属性私有化，对每个属性提供getter和setter方法，如果有一个带参的构造函数的话，那一定要写一个不带参的构造函数。
在开发的时候经常要对已经编写的类进行测试，所以在有的时候还有重写toString方法，但这不是必须的。
继承：

1.目的：实现代码的复用。

2.介绍：当两个类具有相同的特征（属性）和行为（方法）时，可以将相同的部分抽取出来放到一个类中作为父类，其它两个类继承这个父类。
继承后子类自动拥有了父类的属性和方法，但特别注意的是，父类的私有属性和构造方法并不能被继承。另外子类可以写自己特有的属性和方法，
目的是实现功能的扩展，子类也可以复写父类的方法即方法的重写。子类不能继承父类中访问权限为private的成员变量和方法。
子类可以重写父类的方法，及命名与父类同名的成员变量。有时候我们需要这样的需求：我们需要将某些事物尽可能地对这个世界隐藏，
但是仍然允许子类的成员来访问它们。这个时候就需要使用到protected。
对类成员访问的限制及子类继承情况： （从严 到宽 ）
权限修饰符
private 私有，本类内部  不能继承
(default) 本类＋同包  同包子类可继承 
protected 本类＋同包＋子类 可以继承
public 公开   任何地方都可以访问 能继承到子类
覆盖（Override重写）
1、定义： 覆盖了一个方法并且对其重写，以求达到不同的作用。
2、用法：
a、最熟悉的覆盖就是对接口方法的实现
b、在继承中也可能会在子类覆盖父类中的方法
3、产生 “覆盖”的条件：
1、方法名：相同 
2、参数表：相同（个数，类型） 
3、访问限制符：相同或者更宽 
4、返回值类型：相同 或者 子类返回的类型是父类返回的类型的子类 
5、不能抛出比subclass(父类)更多的异常 
注意：当我们在子类中创建的静态方法，它并不会覆盖父类中相同名字的静态方法。
重载(Overload)
重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。
每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。
最常用的地方就是构造器的重载。
重载规则:
    被重载的方法必须改变参数列表(参数个数或类型不一样)；
    被重载的方法可以改变返回类型；
    被重载的方法可以改变访问修饰符；
    被重载的方法可以声明新的或更广的检查异常；
    方法能够在同一个类中或者在一个子类中被重载。
    无法以返回值类型作为重载函数的区分标准
    
    
多态

概念：
对象在不同时刻表现出来的不同状态。
多态的前提：
    要有继承或者实现关系。
    要有方法的重写。
    要有父类引用指向子类对象。
程序中的体现：
父类或者接口的引用指向或者接收自己的子类对象。

好处和作用：
多态的存在提高了程序的扩展性和后期可维护性。

弊端:
父类调用的时候只能调用父类里的方法，不能调用子类的特有方法，因为你并不清楚将来会有什么样的子类继承你。

多态的成员特点：

    成员变量：编译时期：看引用型变量所属的类中是否有所调用的变量；
    运行时期：也是看引用型变量所属的类是否有调用的变量。
    成员变量无论编译还是运行都看引用型变量所属的类，简单记成员变量，编译和运行都看等号左边。
    成员方法：编译时期：要查看引用变量所属的类中是否有所调用的成员；
    运行时期：要查看对象所属的类中是否有所调用的成员。如果父子出现同名的方法,会运行子类中的方法,因为方法有覆盖的特性。
    编译看左边运行看右边。
    静态方法:编译时期：看的引用型变量所属的类中是否有所调用的变量；
    运行时期：也是看引用型变量所属的类是否有调用的变量。
    编译和运行都看等号左边。

一定不能够将父类的对象转换成子类类型！

父类的引用指向子类对象，该引用可以被提升，也可以被强制转换。

多态自始至终都是子类对象在变化！

public class Test {
    public static void main(String[] args) {
      show(new Cat());  // 以 Cat 对象调用 show 方法
      show(new Dog());  // 以 Dog 对象调用 show 方法
                
      Animal a = new Cat();  // 向上转型  
      a.eat();               // 调用的是 Cat 的 eat
      Cat c = (Cat)a;        // 向下转型  
      c.work();        // 调用的是 Cat 的 work
  }  
            
    public static void show(Animal a)  {
      a.eat();  
        // 类型判断
        if (a instanceof Cat)  {  // 猫做的事情 
            Cat c = (Cat)a;  
            c.work();  
        } else if (a instanceof Dog) { // 狗做的事情 
            Dog c = (Dog)a;  
            c.work();  
        }  
    }  
}
 
abstract class Animal {  
    abstract void eat();  
}  
  
class Cat extends Animal {  
    public void eat() {  
        System.out.println("吃鱼");  
    }  
    public void work() {  
        System.out.println("抓老鼠");  
    }  
}  
  
class Dog extends Animal {  
    public void eat() {  
        System.out.println("吃骨头");  
    }  
    public void work() {  
        System.out.println("看家");  
    }  
}








抽象类注意事项：

抽象类不能被实例化，为什么还有构造函数？

只要是class定义的类里面就肯定有构造函数。抽象类中的函数是给子类实例化的。

一个类没有抽象方法，为什么定义为抽象类?

不想被继承，还不想被实例化。

抽象关键字abstract不可以和哪些关键字共存？

    final：如果方法被抽象，就需要被覆盖，而final是不可以被覆盖，所以冲突。
    private：如果函数被私有了，子类无法直接访问，怎么覆盖呢？
    static：不需要对象，类名就可以调用抽象方法。而调用抽象方法没有意义。

接口（interface）

接口是抽象方法和常量值的集合。从本质上讲，接口是一种特殊的抽象类，这种抽象类只包含常量和方法的定义，而没有变量和方法的实现。

格式：interface 接口名{}

接口的出现将”多继承“通过另一种形式体现出来，即”多实现“。

实现（implements）

格式：class 类名 implements 接口名 {}

特点：

    接口不能被实例化。
    一个类如果实现了接口，要么是抽象类，要么实现接口中的所有方法。

接口的成员特点：

接口中的成员修饰符是固定的！

    成员常量：public static final，接口里定义的变量是全局常量，而且修饰符只能是这三个关键字，都可以省略，常量名要大写。
    成员方法：public abstract，接口里定义的方法都是抽象的，两个修饰符关键字可省略。
    推荐：永远手动给出修饰符。

继承与实现的区别：

    类与类之间称为继承关系：因为该类无论是抽象的还是非抽象的，它的内部都可以定义非抽象方法，这个方法可以直接被子类使用，子类继承即可。只能单继承，可以多层继承。（(class)）
    类与接口之间是实现关系：因为接口中的方法都是抽象的，必须由子类实现才可以实例化。可以单实现，也可以多实现；还可以在继承一个类的同时实现多个接口。（(class) extends (class) implements (interface1,interface2…)）
    接口与接口之间是继承关系：一个接口可以继承另一个接口，并添加新的属性和抽象方法，并且接口可以多继承。（(interface) extends (interface1,interface2…)）

抽象类和接口的区别：

成员变量
    抽象类能有变量也可以有常量
    接口只能有常量
成员方法
    抽象类可以有非抽象的方法,也可以有抽象的方法
    接口只能有抽象的方法
构造方法
-抽象类有构造方法
-接口没有构造方法
类与抽象类和接口的关系
    类与抽象类的关系是继承 extends
    类与接口的关系是实现 implements
接口的思想特点：
    接口是对外暴露的规则；
    接口是程序的功能扩展；
    接口的出现降低耦合性；(实现了模块化开发,定义好规则,每个人实现自己的模块,大大提高了开发效率)
    接口可以用来多实现；
    多个无关的类可以实现同一个接口；
    一个类可以实现多个相互直接没有关系的接口；
    与继承关系类似，接口与实现类之间存在多态性。
